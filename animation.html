<style>
    body {
        margin: 0;
        overflow: hidden; 
        background-color: #000000; 
        color: white; 
        font-family: 'Courier New', monospace; 
    }
    canvas {
        display: block; 
        width: 100%; 
        height: 100%; 
    }
    #ui {
        position: absolute;
        top: 15px; 
        width: 100%;
        text-align: center;
        z-index: 100; 
        pointer-events: none; 
    }
    #info {
        font-size: 14px;
        padding: 10px 18px; 
        background-color: rgba(25, 30, 50, 0.35); 
        border-radius: 10px; 
        display: inline-block;
        text-shadow: 0 0 5px rgba(0, 128, 255, 0.8); 
        border: 1px solid rgba(255, 255, 255, 0.1); 
        backdrop-filter: blur(10px); 
        -webkit-backdrop-filter: blur(10px); 
        transition: all 0.3s ease; 
        box-shadow: inset 0 0 10px rgba(255, 255, 255, 0.05); 
    }
    #loading {
        position: fixed;
        width: 100%;
        height: 100%;
        background: #000;
        display: flex;
        flex-direction: column; 
        justify-content: center;
        align-items: center;
        z-index: 1000; 
        transition: opacity 0.6s ease-out; 
    }
    #loading span {
        font-size: 24px;
        letter-spacing: 2px;
        margin-bottom: 15px; 
    }
    #progress-container {
         width: 60%;
         max-width: 300px;
         height: 6px;
         background-color: rgba(255, 255, 255, 0.1);
         border-radius: 3px;
         overflow: hidden; 
    }
    #progress {
        height: 100%;
        width: 0%; 
        background: linear-gradient(90deg, #00a2ff, #00ffea); 
        transition: width 0.3s ease; 
        border-radius: 3px;
    }
    #controls {
        position: absolute;
        bottom: 20px; 
        left: 50%;
        transform: translateX(-50%); 
        z-index: 100;
        text-align: center;
        pointer-events: all; 
        background-color: rgba(25, 30, 50, 0.4); 
        padding: 15px 25px; 
        border-radius: 12px; 
        border: 1px solid rgba(255, 255, 255, 0.12); 
        backdrop-filter: blur(12px); 
         -webkit-backdrop-filter: blur(12px); 
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2); 
    }
    button {
        background: rgba(0, 80, 180, 0.7); 
        color: white;
        border: 1px solid rgba(0, 180, 255, 0.6); 
        border-radius: 6px;
        padding: 8px 15px;
        margin: 0 8px;
        cursor: pointer;
        font-family: 'Courier New', monospace;
        font-size: 14px;
        transition: all 0.25s ease;
    }
    button:hover {
        background: rgba(0, 110, 220, 0.9); 
        border-color: rgba(0, 210, 255, 0.9);
        transform: translateY(-1px);
        box-shadow: 0 3px 8px rgba(0, 150, 255, 0.3);
    }
    #color-picker {
        margin-top: 15px; 
        display: flex;
        justify-content: center;
        gap: 12px;
    }
    .color-option {
        width: 24px;
        height: 24px;
        border-radius: 50%;
        border: 2px solid rgba(255, 255, 255, 0.2); 
        cursor: pointer;
        transition: all 0.2s ease;
        box-shadow: inset 0 0 4px rgba(0,0,0,0.4); 
    }
    .color-option:hover {
        transform: scale(1.15);
        border-color: rgba(255, 255, 255, 0.7); 
    }
     .color-option.active {
         transform: scale(1.18);
         border-color: white;
         box-shadow: 0 0 10px rgba(255, 255, 255, 0.7); 
     }
</style>

<div id="loading">
    <span>Initializing Particles...</span>
    <div id="progress-container">
         <div id="progress"></div>
    </div>
</div>

<div id="ui">
    <div id="info">Shape: Sphere (Click to morph)</div>
</div>

<div id="controls">
    <button id="shape-btn">Change Shape</button>

    <div id="color-picker">
        <div class="color-option" data-scheme="fire" style="background: linear-gradient(to bottom right, #ff4500, #ffcc00)"></div>
        <div class="color-option" data-scheme="neon" style="background: linear-gradient(to bottom right, #ff00ff, #00ffff)"></div>
        <div class="color-option" data-scheme="nature" style="background: linear-gradient(to bottom right, #00ff00, #66ffcc)"></div>
        <div class="color-option" data-scheme="rainbow" style="background: linear-gradient(to right, red, orange, yellow, green, blue, indigo, violet)"></div>
    </div>
</div>

<canvas id="webglCanvas"></canvas>

<script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.163.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.163.0/examples/jsm/",
      "animejs": "https://cdn.jsdelivr.net/npm/animejs@3.2.2/lib/anime.es.js",
      "simplex-noise": "https://cdn.skypack.dev/simplex-noise@4.0.1"
    }
  }
</script>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
    import anime from 'animejs';
    import { createNoise3D, createNoise4D } from 'simplex-noise';

    let scene, camera, renderer, controls, clock;
    let composer, bloomPass; 

    let particlesGeometry, particlesMaterial, particleSystem;
    let currentPositions, sourcePositions, targetPositions, swarmPositions; 
    let particleSizes, particleOpacities, particleEffectStrengths; 
    let noise3D, noise4D; 

    let morphTimeline = null; 
    let isInitialized = false;
    let isMorphing = false;

    const CONFIG = {
        particleCount: 15000,
        shapeSize: 14,
        swarmDistanceFactor: 1.5,
        swirlFactor: 4.0,
        noiseFrequency: 0.1,
        noiseTimeScale: 0.04,
        noiseMaxStrength: 2.8,
        colorScheme: 'fire',
        morphDuration: 4000,
        particleSizeRange: [0.08, 0.25],
        starCount: 18000,
        bloomStrength: 1.3,
        bloomRadius: 0.5,
        bloomThreshold: 0.05,
        idleFlowStrength: 0.25,
        idleFlowSpeed: 0.08,
        idleRotationSpeed: 0.02,
        morphSizeFactor: 0.5, 
        morphBrightnessFactor: 0.6 
    };

    const SHAPES = [
        { name: 'Airplane', generator: generateAirplane },
        { name: 'Package', generator: generatePackage },
        { name: 'Truck', generator: generateTruck },
        { name: 'Globe', generator: generateGlobe },
        { name: 'EMEX Logo', generator: generateLogo }
    ];
    let currentShapeIndex = 0;

    const morphState = { progress: 0.0 };

    const COLOR_SCHEMES = {
        fire: { startHue: 0, endHue: 45, saturation: 0.95, lightness: 0.6 },
        neon: { startHue: 300, endHue: 180, saturation: 1.0, lightness: 0.65 },
        nature: { startHue: 90, endHue: 160, saturation: 0.85, lightness: 0.55 },
        rainbow: { startHue: 0, endHue: 360, saturation: 0.9, lightness: 0.6 }
    };

    const tempVec = new THREE.Vector3();
    const sourceVec = new THREE.Vector3();
    const targetVec = new THREE.Vector3();
    const swarmVec = new THREE.Vector3();
    const noiseOffset = new THREE.Vector3();
    const flowVec = new THREE.Vector3();
    const bezPos = new THREE.Vector3();
    const swirlAxis = new THREE.Vector3();
    const currentVec = new THREE.Vector3();

    function generateAirplane(count, size) {
        const points = new Float32Array(count * 3);
        const bodyLength = size * 1.5;
        const bodyWidth = size * 0.3;
        const bodyHeight = size * 0.3;
        const wingLength = size * 0.8;
        const wingWidth = size * 1.2;
        const tailHeight = size * 0.5;
        const tailWidth = size * 0.4;
        
        for (let i = 0; i < count; i++) {
            const section = Math.random();
            let x, y, z;
            
            if (section < 0.6) { // Main body (60% of points)
                x = (Math.random() - 0.5) * bodyWidth;
                y = (Math.random() - 0.5) * bodyHeight;
                z = (Math.random() - 0.5) * bodyLength;
                // Make body more aerodynamic (narrower at front)
                const taperFactor = (z + bodyLength/2) / bodyLength;
                x *= taperFactor * 0.8 + 0.2;
                y *= taperFactor * 0.8 + 0.2;
            } else if (section < 0.9) { // Wings (30% of points)
                const wingZ = (Math.random() - 0.5) * (bodyLength * 0.5);
                const wingX = (Math.random() < 0.5 ? 1 : -1) * (Math.random() * wingLength + bodyWidth/2);
                const wingTaper = 1 - Math.abs(wingX) / wingLength;
                x = wingX;
                y = (Math.random() - 0.5) * bodyHeight * 0.5;
                z = wingZ * wingTaper;
            } else { // Tail (10% of points)
                const isTailFin = Math.random() < 0.5;
                if (isTailFin) { // Vertical tail fin
                    x = (Math.random() - 0.5) * tailWidth * 0.3;
                    y = Math.random() * tailHeight;
                    z = -bodyLength/2 + Math.random() * tailWidth;
                } else { // Horizontal tail
                    x = (Math.random() < 0.5 ? 1 : -1) * (Math.random() * tailWidth);
                    y = (Math.random() - 0.5) * bodyHeight * 0.5;
                    z = -bodyLength/2 + Math.random() * tailWidth * 0.8;
                }
            }
            
            points[i * 3] = x;
            points[i * 3 + 1] = y;
            points[i * 3 + 2] = z;
        }
        return points;
    }
    function generatePackage(count, size) {
        const points = new Float32Array(count * 3);
        const boxWidth = size * 0.8;
        const boxHeight = size * 0.6;
        const boxDepth = size * 0.8;
        const halfWidth = boxWidth / 2;
        const halfHeight = boxHeight / 2;
        const halfDepth = boxDepth / 2;
        const tapeWidth = boxWidth * 0.1;
        
        for (let i = 0; i < count; i++) {
            const feature = Math.random();
            let x, y, z;
            
            if (feature < 0.85) { // Box surface (85% of points)
                const face = Math.floor(Math.random() * 6);
                const u = Math.random() * boxWidth - halfWidth;
                const v = Math.random() * boxHeight - halfHeight;
                const w = Math.random() * boxDepth - halfDepth;
                
                switch (face) {
                    case 0: x = halfWidth; y = u; z = v; break;  // Right face
                    case 1: x = -halfWidth; y = u; z = v; break; // Left face
                    case 2: x = u; y = halfHeight; z = v; break; // Top face
                    case 3: x = u; y = -halfHeight; z = v; break; // Bottom face
                    case 4: x = u; y = v; z = halfDepth; break;  // Front face
                    case 5: x = u; y = v; z = -halfDepth; break; // Back face
                }
                
                // Add slight bulge to make it look like a filled package
                const distFromCenter = Math.sqrt(x*x + y*y + z*z);
                const bulge = 1.0 + (1.0 - distFromCenter / (size/2)) * 0.05;
                x *= bulge; y *= bulge; z *= bulge;
                
            } else { // Packaging tape (15% of points)
                const isCrossTape = Math.random() < 0.5;
                
                if (isCrossTape) { // Horizontal tape
                    x = (Math.random() * 2 - 1) * halfWidth;
                    y = (Math.random() * tapeWidth - tapeWidth/2);
                    z = (Math.random() * 2 - 1) * halfDepth;
                } else { // Vertical tape
                    x = (Math.random() * tapeWidth - tapeWidth/2);
                    y = (Math.random() * 2 - 1) * halfHeight;
                    z = (Math.random() * 2 - 1) * halfDepth;
                }
            }
            
            points[i * 3] = x;
            points[i * 3 + 1] = y;
            points[i * 3 + 2] = z;
        }
        return points;
    }
    function generateTruck(count, size) {
        const points = new Float32Array(count * 3);
        const cabinWidth = size * 0.4;
        const cabinHeight = size * 0.4;
        const cabinDepth = size * 0.3;
        const trailerWidth = size * 0.5;
        const trailerHeight = size * 0.5;
        const trailerDepth = size * 1.0;
        const wheelRadius = size * 0.15;
        
        for (let i = 0; i < count; i++) {
            const section = Math.random();
            let p = new THREE.Vector3();
            
            if (section < 0.25) { // Cabin (25% of points)
                const cabinX = -size/2 + cabinDepth/2;
                const cabinHalfWidth = cabinWidth/2;
                const cabinHalfHeight = cabinHeight/2;
                const cabinHalfDepth = cabinDepth/2;
                
                const face = Math.floor(Math.random() * 6);
                const u = Math.random() * cabinWidth - cabinHalfWidth;
                const v = Math.random() * cabinHeight - cabinHalfHeight;
                const w = Math.random() * cabinDepth - cabinHalfDepth;
                
                switch (face) {
                    case 0: p.set(cabinX + cabinHalfDepth, u, v); break;  // Front
                    case 1: p.set(cabinX - cabinHalfDepth, u, v); break; // Back
                    case 2: p.set(cabinX + w, cabinHalfHeight, u); break; // Top
                    case 3: p.set(cabinX + w, -cabinHalfHeight, u); break; // Bottom
                    case 4: p.set(cabinX + w, v, cabinHalfWidth); break;  // Right
                    case 5: p.set(cabinX + w, v, -cabinHalfWidth); break; // Left
                }
                
            } else if (section < 0.75) { // Trailer (50% of points)
                const trailerX = trailerDepth/2;
                const trailerHalfWidth = trailerWidth/2;
                const trailerHalfHeight = trailerHeight/2;
                const trailerHalfDepth = trailerDepth/2;
                
                const face = Math.floor(Math.random() * 6);
                const u = Math.random() * trailerWidth - trailerHalfWidth;
                const v = Math.random() * trailerHeight - trailerHalfHeight;
                const w = Math.random() * trailerDepth - trailerHalfDepth;
                
                switch (face) {
                    case 0: p.set(trailerX + trailerHalfDepth, u, v); break;  // Front
                    case 1: p.set(trailerX - trailerHalfDepth, u, v); break; // Back
                    case 2: p.set(trailerX + w, trailerHalfHeight, u); break; // Top
                    case 3: p.set(trailerX + w, -trailerHalfHeight, u); break; // Bottom
                    case 4: p.set(trailerX + w, v, trailerHalfWidth); break;  // Right
                    case 5: p.set(trailerX + w, v, -trailerHalfWidth); break; // Left
                }
                
            } else { // Wheels (25% of points)
                const isRearWheel = Math.random() < 0.6; // 60% rear wheels (more of them)
                const isRightSide = Math.random() < 0.5;
                
                const wheelX = isRearWheel ? 
                    (Math.random() * trailerDepth * 0.8 - trailerDepth * 0.4) : 
                    (-size/2 + cabinDepth * 0.3);
                
                const wheelZ = (isRightSide ? 1 : -1) * 
                    (isRearWheel ? trailerWidth/2 : cabinWidth/2);
                
                // Create a wheel (cylinder)
                const angle = Math.random() * Math.PI * 2;
                const radius = wheelRadius * Math.sqrt(Math.random()); // Distribute points evenly
                const wheelY = -size/2 + wheelRadius * 0.8;
                
                p.set(wheelX, wheelY + radius * Math.cos(angle), wheelZ + radius * Math.sin(angle));
            }
            
            points.set([p.x, p.y, p.z], i * 3);
        }
        return points;
    }
    function generateGlobe(count, size) {
        const points = new Float32Array(count * 3);
        const radius = size * 0.8;
        const continentDensity = 0.6; // Higher density for continents
        const oceanDensity = 0.2;    // Lower density for oceans
        const continentFeatures = 0.15; // Percentage of points for continent features
        
        for (let i = 0; i < count; i++) {
            // Use spherical coordinates for even distribution
            const phi = Math.acos(2 * Math.random() - 1); // Latitude
            const theta = Math.random() * Math.PI * 2;    // Longitude
            
            // Basic sphere point
            let r = radius;
            let x = Math.sin(phi) * Math.cos(theta);
            let y = Math.sin(phi) * Math.sin(theta);
            let z = Math.cos(phi);
            
            // Determine if this point is on a "continent" or "ocean"
            // Using simplex-like noise pattern for continents
            const lat = phi / Math.PI; // 0 to 1
            const lng = theta / (Math.PI * 2); // 0 to 1
            
            // Simple continent pattern (could be replaced with actual simplex noise)
            const isContinent = Math.sin(lat * 6) * Math.sin(lng * 6) > 0.2;
            
            if (isContinent) {
                // Add slight elevation for continents
                r *= 1.02 + Math.random() * 0.03;
                
                // Add continent features (mountains, etc)
                if (Math.random() < continentFeatures) {
                    r *= 1.04 + Math.random() * 0.04;
                }
            } else {
                // Slightly lower oceans
                r *= 0.99 + Math.random() * 0.01;
            }
            
            // Apply final radius
            x *= r;
            y *= r;
            z *= r;
            
            points[i * 3] = x;
            points[i * 3 + 1] = y;
            points[i * 3 + 2] = z;
        }
        return points;
    }
    function generateLogo(count, size) {
        const points = new Float32Array(count * 3);
        // EMEX EXPRESS logo - stylized 'E' shape with express lines
        const letterWidth = size * 1.2;
        const letterHeight = size * 1.5;
        const letterThickness = size * 0.2;
        const expressLinesCount = 3;
        
        for (let i = 0; i < count; i++) {
            let p = new THREE.Vector3();
            const feature = Math.random();
            
            if (feature < 0.7) { // Main 'E' shape (70% of points)
                const part = Math.random();
                
                if (part < 0.25) { // Vertical bar of 'E'
                    const x = -letterWidth/2;
                    const y = (Math.random() * 2 - 1) * letterHeight/2;
                    const z = (Math.random() * 2 - 1) * letterThickness/2;
                    p.set(x, y, z);
                } else { // Horizontal bars of 'E'
                    let barY;
                    if (part < 0.5) { // Top bar
                        barY = letterHeight/2;
                    } else if (part < 0.75) { // Middle bar
                        barY = 0;
                    } else { // Bottom bar
                        barY = -letterHeight/2;
                    }
                    
                    const barLength = (part < 0.5 || part >= 0.75) ? letterWidth : letterWidth * 0.8;
                    const x = -letterWidth/2 + Math.random() * barLength;
                    const y = barY + (Math.random() * 2 - 1) * letterThickness/2;
                    const z = (Math.random() * 2 - 1) * letterThickness/2;
                    p.set(x, y, z);
                }
                
                // Add slight 3D effect with depth variation
                p.z += (Math.random() * 2 - 1) * letterThickness * 0.5;
                
            } else if (feature < 0.9) { // EXPRESS lines (20% of points)
                // Create flowing lines to the right of the 'E'
                const lineY = (Math.random() * 2 - 1) * letterHeight/2;
                const lineIndex = Math.floor(Math.random() * expressLinesCount);
                const lineOffset = (lineIndex / expressLinesCount) * letterHeight - letterHeight/2;
                
                const x = Math.random() * letterWidth * 0.8;
                const y = lineOffset + (Math.random() * 2 - 1) * letterThickness/3;
                const z = (Math.random() * 2 - 1) * letterThickness/2;
                
                p.set(x, y, z);
                
            } else { // EMEX dots/accents (10% of points)
                // Create accent points that form a subtle glow or highlight
                const angle = Math.random() * Math.PI * 2;
                const radius = size * (0.2 + Math.random() * 0.1);
                const x = Math.cos(angle) * radius;
                const y = Math.sin(angle) * radius;
                const z = (Math.random() * 2 - 1) * letterThickness;
                
                p.set(x, y, z);
            }
            
            // Apply a slight curve to the entire logo for dynamic effect
            const curveFactor = 0.2;
            p.z += curveFactor * Math.sin(p.y / letterHeight * Math.PI);
            
            points[i * 3] = p.x;
            points[i * 3 + 1] = p.y;
            points[i * 3 + 2] = p.z;
        }
        return points;
    }
    // Wave shape removed as requested

    function init() {
        let progress = 0;
        const progressBar = document.getElementById('progress');
        const loadingScreen = document.getElementById('loading');
        function updateProgress(increment) {
            progress += increment;
            progressBar.style.width = `${Math.min(100, progress)}%`;
            if (progress >= 100) {
                setTimeout(() => {
                    loadingScreen.style.opacity = '0';
                    setTimeout(() => { loadingScreen.style.display = 'none'; }, 600);
                }, 200);
            }
        }

        clock = new THREE.Clock();
        noise3D = createNoise3D(() => Math.random());
        noise4D = createNoise4D(() => Math.random());
        scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000308, 0.03);
        updateProgress(5);

        camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 8, 28); 
        camera.lookAt(scene.position);
        updateProgress(5);

        const canvas = document.getElementById('webglCanvas');
        renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true, powerPreference: 'high-performance' });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.1;
        updateProgress(10);

        controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true; controls.dampingFactor = 0.05;
        controls.minDistance = 5; controls.maxDistance = 80;
        controls.autoRotate = true; controls.autoRotateSpeed = 0.3;
        updateProgress(5);

        scene.add(new THREE.AmbientLight(0x404060));
        const dirLight1 = new THREE.DirectionalLight(0xffffff, 1.5);
        dirLight1.position.set(15, 20, 10); scene.add(dirLight1);
        const dirLight2 = new THREE.DirectionalLight(0x88aaff, 0.9);
        dirLight2.position.set(-15, -10, -15); scene.add(dirLight2);
        updateProgress(10);

        setupPostProcessing(); updateProgress(10);
        createStarfield(); updateProgress(15);
        setupParticleSystem(); updateProgress(25);

        window.addEventListener('resize', onWindowResize);
        window.addEventListener('click', onCanvasClick);
        document.getElementById('shape-btn').addEventListener('click', triggerMorph);
        document.querySelectorAll('.color-option').forEach(option => {
            option.addEventListener('click', (e) => {
                document.querySelectorAll('.color-option').forEach(o => o.classList.remove('active'));
                e.target.classList.add('active');
                CONFIG.colorScheme = e.target.dataset.scheme;
                updateColors();
            });
        });
        document.querySelector(`.color-option[data-scheme="${CONFIG.colorScheme}"]`).classList.add('active');
        updateProgress(15);

        isInitialized = true;
        animate();
        console.log("Initialization complete.");
    }

    function setupPostProcessing() {
        composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), CONFIG.bloomStrength, CONFIG.bloomRadius, CONFIG.bloomThreshold);
        composer.addPass(bloomPass);
    }

    function createStarfield() {
        const starVertices = []; const starSizes = []; const starColors = [];
        const starGeometry = new THREE.BufferGeometry();
        for (let i = 0; i < CONFIG.starCount; i++) {
            tempVec.set( THREE.MathUtils.randFloatSpread(400), THREE.MathUtils.randFloatSpread(400), THREE.MathUtils.randFloatSpread(400) );
            if (tempVec.length() < 100) tempVec.setLength(100 + Math.random() * 300);
            starVertices.push(tempVec.x, tempVec.y, tempVec.z);
            starSizes.push(Math.random() * 0.15 + 0.05);
            const color = new THREE.Color();
            if (Math.random() < 0.1) { color.setHSL(Math.random(), 0.7, 0.65); } else { color.setHSL(0.6, Math.random() * 0.1, 0.8 + Math.random() * 0.2); }
            starColors.push(color.r, color.g, color.b);
        }
        starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
        starGeometry.setAttribute('color', new THREE.Float32BufferAttribute(starColors, 3));
        starGeometry.setAttribute('size', new THREE.Float32BufferAttribute(starSizes, 1));
        const starMaterial = new THREE.ShaderMaterial({
             uniforms: { pointTexture: { value: createStarTexture() } },
             vertexShader: `
                  attribute float size; varying vec3 vColor; varying float vSize;
                  void main() {
                       vColor = color; vSize = size; vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                       gl_PointSize = size * (400.0 / -mvPosition.z); gl_Position = projectionMatrix * mvPosition;
                  }`,
             fragmentShader: `
                  uniform sampler2D pointTexture; varying vec3 vColor; varying float vSize;
                  void main() {
                       float alpha = texture2D(pointTexture, gl_PointCoord).a; if (alpha < 0.1) discard;
                       gl_FragColor = vec4(vColor, alpha * 0.9);
                  }`,
             blending: THREE.AdditiveBlending, depthWrite: false, transparent: true, vertexColors: true
         });
        scene.add(new THREE.Points(starGeometry, starMaterial));
    }

    function createStarTexture() {
        const size = 64; const canvas = document.createElement('canvas');
        canvas.width = size; canvas.height = size; const context = canvas.getContext('2d');
        const gradient = context.createRadialGradient(size / 2, size / 2, 0, size / 2, size / 2, size / 2);
        gradient.addColorStop(0, 'rgba(255,255,255,1)'); gradient.addColorStop(0.2, 'rgba(255,255,255,0.8)');
        gradient.addColorStop(0.5, 'rgba(255,255,255,0.3)'); gradient.addColorStop(1, 'rgba(255,255,255,0)');
        context.fillStyle = gradient; context.fillRect(0, 0, size, size);
        return new THREE.CanvasTexture(canvas);
    }

    function setupParticleSystem() {
        targetPositions = SHAPES.map(shape => shape.generator(CONFIG.particleCount, CONFIG.shapeSize));
        particlesGeometry = new THREE.BufferGeometry();

        currentPositions = new Float32Array(targetPositions[0]);
        sourcePositions = new Float32Array(targetPositions[0]);
        swarmPositions = new Float32Array(CONFIG.particleCount * 3);
        particlesGeometry.setAttribute('position', new THREE.BufferAttribute(currentPositions, 3));

        particleSizes = new Float32Array(CONFIG.particleCount);
        particleOpacities = new Float32Array(CONFIG.particleCount);
        particleEffectStrengths = new Float32Array(CONFIG.particleCount);
        for (let i = 0; i < CONFIG.particleCount; i++) {
            particleSizes[i] = THREE.MathUtils.randFloat(CONFIG.particleSizeRange[0], CONFIG.particleSizeRange[1]);
            particleOpacities[i] = 1.0;
            particleEffectStrengths[i] = 0.0;
        }
        particlesGeometry.setAttribute('size', new THREE.BufferAttribute(particleSizes, 1));
        particlesGeometry.setAttribute('opacity', new THREE.BufferAttribute(particleOpacities, 1));
        particlesGeometry.setAttribute('aEffectStrength', new THREE.BufferAttribute(particleEffectStrengths, 1));

        const colors = new Float32Array(CONFIG.particleCount * 3);
        updateColorArray(colors, currentPositions);
        particlesGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        particlesMaterial = new THREE.ShaderMaterial({
             uniforms: {
                  pointTexture: { value: createStarTexture() }
             },
             vertexShader: `
                  attribute float size;
                  attribute float opacity;
                  attribute float aEffectStrength;
                  varying vec3 vColor;
                  varying float vOpacity;
                  varying float vEffectStrength;

                  void main() {
                       vColor = color;
                       vOpacity = opacity;
                       vEffectStrength = aEffectStrength;

                       vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);

                       float sizeScale = 1.0 - vEffectStrength * ${CONFIG.morphSizeFactor.toFixed(2)};
                       gl_PointSize = size * sizeScale * (400.0 / -mvPosition.z);

                       gl_Position = projectionMatrix * mvPosition;
                  }
             `,
             fragmentShader: `
                  uniform sampler2D pointTexture;
                  varying vec3 vColor;
                  varying float vOpacity;
                  varying float vEffectStrength;

                  void main() {
                       float alpha = texture2D(pointTexture, gl_PointCoord).a;
                       if (alpha < 0.05) discard;

                       vec3 finalColor = vColor * (1.0 + vEffectStrength * ${CONFIG.morphBrightnessFactor.toFixed(2)});

                       gl_FragColor = vec4(finalColor, alpha * vOpacity);
                  }
             `,
             blending: THREE.AdditiveBlending,
             depthTest: true,
             depthWrite: false,
             transparent: true,
             vertexColors: true
        });

        particleSystem = new THREE.Points(particlesGeometry, particlesMaterial);
        scene.add(particleSystem);
    }

    function updateColorArray(colors, positionsArray) {
        const colorScheme = COLOR_SCHEMES[CONFIG.colorScheme];
        const center = new THREE.Vector3(0, 0, 0);
        const maxRadius = CONFIG.shapeSize * 1.1;
        for (let i = 0; i < CONFIG.particleCount; i++) {
            const i3 = i * 3;
            tempVec.fromArray(positionsArray, i3);
            const dist = tempVec.distanceTo(center);
            let hue;
            if (CONFIG.colorScheme === 'rainbow') {
                const normX = (tempVec.x / maxRadius + 1) / 2; const normY = (tempVec.y / maxRadius + 1) / 2; const normZ = (tempVec.z / maxRadius + 1) / 2;
                hue = (normX * 120 + normY * 120 + normZ * 120) % 360;
            } else {
                hue = THREE.MathUtils.mapLinear( dist, 0, maxRadius, colorScheme.startHue, colorScheme.endHue );
            }
            const noiseValue = (noise3D(tempVec.x * 0.2, tempVec.y * 0.2, tempVec.z * 0.2) + 1) * 0.5;
            const saturation = THREE.MathUtils.clamp(colorScheme.saturation * (0.9 + noiseValue * 0.2), 0, 1);
            const lightness = THREE.MathUtils.clamp(colorScheme.lightness * (0.85 + noiseValue * 0.3), 0.1, 0.9);
            const color = new THREE.Color().setHSL(hue / 360, saturation, lightness);
            color.toArray(colors, i3);
        }
    }

    function updateColors() {
        const colors = particlesGeometry.attributes.color.array;
        updateColorArray(colors, particlesGeometry.attributes.position.array);
        particlesGeometry.attributes.color.needsUpdate = true;
    }

    function triggerMorph() {
        if (isMorphing) return;
        isMorphing = true; controls.autoRotate = false; console.log("Morphing triggered...");
        document.getElementById('info').innerText = `Morphing...`;
        document.getElementById('info').style.textShadow = '0 0 8px rgba(255, 150, 50, 0.9)';
        sourcePositions.set(currentPositions);
        const nextShapeIndex = (currentShapeIndex + 1) % SHAPES.length;
        const nextTargetPositions = targetPositions[nextShapeIndex];
        const centerOffsetAmount = CONFIG.shapeSize * CONFIG.swarmDistanceFactor;
        for (let i = 0; i < CONFIG.particleCount; i++) {
            const i3 = i * 3;
            sourceVec.fromArray(sourcePositions, i3); targetVec.fromArray(nextTargetPositions, i3);
            swarmVec.lerpVectors(sourceVec, targetVec, 0.5);
            const offsetDir = tempVec.set( noise3D(i * 0.05, 10, 10), noise3D(20, i * 0.05, 20), noise3D(30, 30, i * 0.05) ).normalize();
            const distFactor = sourceVec.distanceTo(targetVec) * 0.1 + centerOffsetAmount;
            swarmVec.addScaledVector(offsetDir, distFactor * (0.5 + Math.random() * 0.8));
            swarmPositions[i3] = swarmVec.x; swarmPositions[i3 + 1] = swarmVec.y; swarmPositions[i3 + 2] = swarmVec.z;
        }
        currentShapeIndex = nextShapeIndex;
        morphState.progress = 0;
        if (morphTimeline) morphTimeline.pause();
        morphTimeline = anime({
             targets: morphState, progress: 1, duration: CONFIG.morphDuration, easing: 'cubicBezier(0.4, 0.0, 0.2, 1.0)',
             complete: () => {
                 console.log("Morphing complete.");
                 document.getElementById('info').innerText = `Shape: ${SHAPES[currentShapeIndex].name} (Click to morph)`;
                 document.getElementById('info').style.textShadow = '0 0 5px rgba(0, 128, 255, 0.8)';
                 currentPositions.set(targetPositions[currentShapeIndex]);
                 particlesGeometry.attributes.position.needsUpdate = true;
                 particleEffectStrengths.fill(0.0);
                 particlesGeometry.attributes.aEffectStrength.needsUpdate = true;
                 sourcePositions.set(targetPositions[currentShapeIndex]);
                 updateColors();
                 isMorphing = false; controls.autoRotate = true;
             }
        });
    }

    function animate() {
        requestAnimationFrame(animate);
        if (!isInitialized) return;
        const elapsedTime = clock.getElapsedTime();
        const deltaTime = clock.getDelta();
        controls.update();
        const positions = particlesGeometry.attributes.position.array;
        const effectStrengths = particlesGeometry.attributes.aEffectStrength.array;

        if (isMorphing) {
            updateMorphAnimation(positions, effectStrengths, elapsedTime, deltaTime);
        } else {
            updateIdleAnimation(positions, effectStrengths, elapsedTime, deltaTime);
        }
        particlesGeometry.attributes.position.needsUpdate = true;
        if (isMorphing || particlesGeometry.attributes.aEffectStrength.needsUpdate) {
             particlesGeometry.attributes.aEffectStrength.needsUpdate = true;
        }
        composer.render(deltaTime);
    }

    function updateMorphAnimation(positions, effectStrengths, elapsedTime, deltaTime) {
        const t = morphState.progress;
        const targets = targetPositions[currentShapeIndex];
        const effectStrength = Math.sin(t * Math.PI);
        const currentSwirl = effectStrength * CONFIG.swirlFactor * deltaTime * 50;
        const currentNoise = effectStrength * CONFIG.noiseMaxStrength;

        for (let i = 0; i < CONFIG.particleCount; i++) {
            const i3 = i * 3;
            sourceVec.fromArray(sourcePositions, i3);
            swarmVec.fromArray(swarmPositions, i3);
            targetVec.fromArray(targets, i3);

            const t_inv = 1.0 - t; const t_inv_sq = t_inv * t_inv; const t_sq = t * t;
            bezPos.copy(sourceVec).multiplyScalar(t_inv_sq);
            bezPos.addScaledVector(swarmVec, 2.0 * t_inv * t);
            bezPos.addScaledVector(targetVec, t_sq);

            if (currentSwirl > 0.01) {
                tempVec.subVectors(bezPos, sourceVec);
                swirlAxis.set( noise3D(i * 0.02, elapsedTime * 0.1, 0), noise3D(0, i * 0.02, elapsedTime * 0.1 + 5), noise3D(elapsedTime * 0.1 + 10, 0, i * 0.02) ).normalize();
                tempVec.applyAxisAngle(swirlAxis, currentSwirl * (0.5 + Math.random() * 0.5));
                bezPos.copy(sourceVec).add(tempVec);
            }

            if (currentNoise > 0.01) {
                const noiseTime = elapsedTime * CONFIG.noiseTimeScale;
                noiseOffset.set( noise4D(bezPos.x * CONFIG.noiseFrequency, bezPos.y * CONFIG.noiseFrequency, bezPos.z * CONFIG.noiseFrequency, noiseTime), noise4D(bezPos.x * CONFIG.noiseFrequency + 100, bezPos.y * CONFIG.noiseFrequency + 100, bezPos.z * CONFIG.noiseFrequency + 100, noiseTime), noise4D(bezPos.x * CONFIG.noiseFrequency + 200, bezPos.y * CONFIG.noiseFrequency + 200, bezPos.z * CONFIG.noiseFrequency + 200, noiseTime) );
                bezPos.addScaledVector(noiseOffset, currentNoise);
            }

            positions[i3] = bezPos.x;
            positions[i3 + 1] = bezPos.y;
            positions[i3 + 2] = bezPos.z;

            effectStrengths[i] = effectStrength;
        }
         particlesGeometry.attributes.aEffectStrength.needsUpdate = true;
    }

    function updateIdleAnimation(positions, effectStrengths, elapsedTime, deltaTime) {
        const breathScale = 1.0 + Math.sin(elapsedTime * 0.5) * 0.015;
        const timeScaled = elapsedTime * CONFIG.idleFlowSpeed;
        const freq = 0.1;

        let needsEffectStrengthReset = false;

        for (let i = 0; i < CONFIG.particleCount; i++) {
            const i3 = i * 3;
            sourceVec.fromArray(sourcePositions, i3);
            tempVec.copy(sourceVec).multiplyScalar(breathScale);
            flowVec.set( noise4D(tempVec.x * freq, tempVec.y * freq, tempVec.z * freq, timeScaled), noise4D(tempVec.x * freq + 10, tempVec.y * freq + 10, tempVec.z * freq + 10, timeScaled), noise4D(tempVec.x * freq + 20, tempVec.y * freq + 20, tempVec.z * freq + 20, timeScaled) );
            tempVec.addScaledVector(flowVec, CONFIG.idleFlowStrength);
            currentVec.fromArray(positions, i3);
            currentVec.lerp(tempVec, 0.05);
            positions[i3] = currentVec.x;
            positions[i3 + 1] = currentVec.y;
            positions[i3 + 2] = currentVec.z;

            if (effectStrengths[i] !== 0.0) {
                effectStrengths[i] = 0.0;
                needsEffectStrengthReset = true;
            }
        }
         if (needsEffectStrengthReset) {
             particlesGeometry.attributes.aEffectStrength.needsUpdate = true;
         }
    }

    function onCanvasClick(event) {
        if (event.target.closest('#controls')) { return; }
        triggerMorph();
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        composer.setSize(window.innerWidth, window.innerHeight);
    }

    init();

</script>